// responsive measurements
$breakpoints: (
    small: 320px,
    medium: 600px,
    large: 768px,
    xlarge: 1024px
);

// respond-to mixin with max-width bounds (exclusive of max)
@mixin respond-to($breakpoint) {
    @if map-has-key($breakpoints, $breakpoint) {
        $value: map-get($breakpoints, $breakpoint);
        $nextvalue: map-get-next($breakpoints, $breakpoint, 10000px);
        @media screen and (min-width: $value) and (max-width: $nextvalue){
            @content;
        }
    }

    @warn "Unknown `#{$breakpoint}` in $breakpoints";
}

// respond-to mixin without max-width bounds (inclusive)
@mixin respond-to-plus($breakpoint) {
    @if map-has-key($breakpoints, $breakpoint) {
        $value: map-get($breakpoints, $breakpoint);
        @media screen and (min-width: $value){
            @content;
        }
    }
}

// respond-to mixin without min-width bounds (inclusive)
@mixin respond-to-minus($breakpoint) {
    @if map-has-key($breakpoints, $breakpoint) {
        $value: map-get($breakpoints, $breakpoint);
        $nextvalue: map-get-next($breakpoints, $breakpoint, 10000px);
        @media screen and (max-width: $nextvalue){
            @content;
        }
    }
}

@mixin shared { // no purpose except for clarity for responsiveness
	@content;
}

// layering
$layer: (
  above: 10
);

@function layer($name) {
  @if map-has-key($layer, $name) {
    @return map-get($layer, $name);
  }

  @warn "The key #{$name} is not in the map ’$layer’";
  @return null;
};

// color-scheming
$colorscheme: (
  gray: (
    base: #ccc,
    light: #f2f2f2,
    dark: #666
  ),
  brown: (
    base: #ab906b,
    light: #ecdac3,
    dark: #5e421c
  )
);

// example usage: @include setcolor(color, *tone)
@function setcolor($scheme, $tone: base) {
    @return map-get(map-get($colorscheme, $scheme), $tone);
}

// containers (columns) - works for single level element wrappers
@mixin container($width, $cols) {
    @for $i from 1 through $cols {
      *:nth-child(#{$i}) {
        @include contained($i, $cols);
        width: 100% / $cols;
      }
   }
}

@mixin contained($i, $cnt){
    @if ($i < $cnt / 2){
        float: left;
    } @elseif ($i == ceil($cnt / 2)){
        display: inline-block;
    } @else {
        float: right;
    }
}

// general functions
@function map-get-next($map, $key, $fallback: false) {

    @if map_has_key($map, $key) {
        $i: 0; // index counter variable
        $key-index: false; // key index variable

        // Traverse map for key
        @each $map-key, $map-value in $map {
            // Update index
            $i: $i + 1;

            // If map key found, set key index
            @if $map-key == $key {
                $key-index: $i;
            }

            // If next index return next value
            @if $i == $key-index + 1 {
                @return $map-value;
            }

            // If last entry return false
            @if $i == length($map) {
                @return $fallback;
            }
        }

        @warn 'No next map item for key #{$key}';
        @return $fallback;
    }

    @warn 'No map item for key #{key}';
    @return $fallback;
}
